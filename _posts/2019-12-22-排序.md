---
title: 排序 
auther: ahou
layout: post
---

^[对原理做概略总结  
后续考虑插入代码和详细分析比较]

假定考虑降序排列  

## 基础排序算法  
平均时间复杂度O(N^2)  

### 1. 选择排序
需要进行N-1趟，每趟进行一次交换，将后面区间中的最小元素交换到对应位置。

### 2. 冒泡排序
每趟中都将相邻元素比较，若前一个比后一个元素大，那么进行交换，每一趟都将最大元素排到尾端对应位置，元素是一步步向后移动。

### 3. 插入排序
插入排序中当前位置左边的元素都是有序的，当前元素与左边元素依次比较，将比他大的元素统一后移一位，然后放到插入位置。

## 高效排序算法
平均时间复杂度O(NlgN)  
### 4. 希尔排序
希尔排序是插入排序的改进版本，它的比较和插入是以间隔h来进行的，同时h逐渐减小(比如h=h/3),最终h变成1后完成排序。
插入排序每次比较都只将元素移动一位，当最小的元素刚好位于最后时，效率比较低，而希尔排序正是借助于每次比较步长为h，可以实现较大间隔的移动(这也导致了它的不稳定，后面讲到)，当h最终等于1时，数组已经趋于有序，不需要过多的操作了。  
**目前最重要的结论是希尔排序的复杂度达不到平方级别。**而进一步准确的结论并不多，希尔排序的性能分析比较复杂。  
### 5. 归并排序
考虑把数组从中间位置分隔开，假定左右两端都已经是有序的，那么只需要将两个有序的数组合并即可(合并过程中通常需要额外存储空间，原地合并方法较为复杂)，其时间复杂度是线性的。  
基于这种思想，通过递归原数组，最终得到单一元素，此时是有序的，然后逐步合并。  
这是分治思想的应用。

### 6. 快速排序
同样采用了分治的思想，从数组中选择一个元素k(一般可直接选第一个),将数组进行划分，最终大于k的都在k的右边，小于等于k的都在k的左边，然后对于左右两边的区间进行同样的递归，最终实现排序。  
快速排序是如今应用极多的排序算法。

### 7. 堆排序
基于堆实现的排序  

高效与基本并非绝对，比如在数据量较小时，快速排序慢于插入排序，有种快速排序的改进就是在子数组容量小于某个值时(5-15之间)，切换到插入排序。

## 排序算法的稳定性
排序算法的稳定性是指，排序中相同值元素的相对位置是否改变。如果算法不能保证其不改变，那么就是不稳定的。  
#### 1. 稳定的排序算法  
**插入排序**  
**冒泡排序**  
**归并排序**  
#### 2. 不稳定的排序算法
**选择排序**  
**快速排序**  
**希尔排序**  
**堆排序**  

如果排序算法中进行了非相邻元素的交换，那么一般它就是不稳定的，因为这种交换可能导致相同的值前后关系改变。  
比如序列[10,8,3,10,6,1],在进行选择排序时(降序),元素1需要与第一个元素10进行交换，此时第一个元素10就排到了第二个元素10的后面，因此影响了稳定性。

## java系统中的排序算法
java.util.Arrays 中的sort()方法基于基本数据类型和引用类型设计了不同的排序方法  
### 1. 对于基本数据类型，采用**三向切分**的**快速排序**算法  
三向切分是在选择划分的值k后，把数组分为小于k，等于k和大于k的三部分，这种改进适应了含有大量重复数据的数组的排序，可以使复杂度逼近线型级别。
### 2. 对于引用类型数据，采用归并排序算法
归并排序是稳定的排序算法，这在引用类型数据中是必要的，因为对象中可能存在其他有顺序意义的字段。  
但归并排序需要额外的空间进行过程中的存储，这里用空间换取了稳定性。