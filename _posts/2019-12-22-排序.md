---
title: 排序 
auther: ahou
layout: post
---

^[对原理做概略总结  
后续考虑插入代码和详细分析比较]

假定考虑降序排列  

## 基础排序算法  
平均时间复杂度O(N^2)  

### 1. 选择排序
需要进行N-1趟，每趟进行一次交换，将后面区间中的最小元素交换到对应位置。

### 2. 冒泡排序
每趟中都将相邻元素比较，若前一个比后一个元素大，那么进行交换，每一趟都将最大元素排到尾端对应位置，元素是一步步向后移动。

### 3. 插入排序
插入排序中当前位置左边的元素都是有序的，当前元素与左边元素依次比较，将比他大的元素统一后移一位，然后放到插入位置。

## 高效排序算法
平均时间复杂度O(NlgN)  
### 4. 希尔排序
希尔排序是插入排序的改进版本，它的比较和插入是以间隔h来进行的，同时h逐渐减小(比如h=h/3),最终h变成1后完成排序。
插入排序每次比较都只将元素移动一位，当最小的元素刚好位于最后时，效率比较低，而希尔排序正是借助于每次比较步长为h，可以实现较大间隔的移动(这也导致了它的不稳定，后面讲到)，当h最终等于1时，数组已经趋于有序，不需要过多的操作了。  
**目前最重要的结论是希尔排序的复杂度达不到平方级别。**而进一步准确的结论并不多，希尔排序的性能分析比较复杂。  
### 5. 归并排序
考虑把数组从中间位置分隔开，假定左右两端都已经是有序的，那么只需要将两个有序的数组合并即可(合并过程中通常需要额外存储空间，原地合并方法较为复杂)，其时间复杂度是线性的。  
基于这种思想，通过递归原数组，最终得到单一元素，此时是有序的，然后逐步合并。  
这是分治思想的应用。

### 6. 快速排序
同样采用了分治的思想，从数组中选择一个元素k(一般可直接选第一个),将数组进行划分，最终大于k的都在k的右边，小于等于k的都在k的左边，然后对于左右两边的区间进行同样的递归，最终实现排序。  
快速排序是如今应用极多的排序算法。

### 7. 堆排序
基于堆实现的排序  
堆排序的优点是不管对于什么数据，时间复杂度最差也能保证O(NLogN)，这是很难得的。
影响堆排序应用的一个缺点是它的比较操作很少在数组相邻元素间进行，缓存命中率低与一般在相邻元素间比较的算法如 **快速排序**，**归并排序**，**插入排序**。

#### 堆的介绍
堆通过二叉树表示，有两种重要操作，数据上浮swam和下沉sink
当向堆中插入数据时，我们将它放入堆的底部，如果它的值大于父节点，将它与父节点交换(上浮),最终一步步浮到合适节点位置。  
当从堆中取出数据时，我们返回并删除堆顶部的值(最大值), 然后把堆的最后一个值放到堆的顶部，将它与较大的子节点比较，如果小于子节点的值，需要把它和子节点交换(下沉),最终一步步沉到合适节点位置。  
#### 通过堆实现排序
在原数组中原地构建堆，然后排序。
1. 构建堆
把数组当做一个完全二叉树的存储容器，索引k的子节点是k*2和k*2+1,父节点为k/2(数组索引0不存储元素)。  
数组中后一半的元素位于叶子节点上，不需要操作，将前一半元素进行下沉操作来调整堆，通过N/2次下沉操作来实现堆的构建。

2. 实现排序
构建好的堆成为大顶堆(根节点为最大元素)，之后只需要将堆定元素移出，将堆底的元素放到堆顶，然后对这个节点进行下沉操作。此时堆的大小减一，并且数组尾部元素空出，刚好将移出的堆顶元素(最大值)放到空出的位置。重复N次，最终数组元素将是从大到小排列的


高效与基本并非绝对，比如在数据量较小时，快速排序慢于插入排序，有种快速排序的改进就是在子数组容量小于某个值时(5-15之间)，切换到插入排序。

## 排序算法的稳定性
排序算法的稳定性是指，排序中相同值元素的相对位置是否改变。如果算法不能保证其不改变，那么就是不稳定的。  
#### 1. 稳定的排序算法  
**插入排序**  
**冒泡排序**  
**归并排序**  
#### 2. 不稳定的排序算法
**选择排序**  
**快速排序**  
**希尔排序**  
**堆排序**  

如果排序算法中进行了非相邻元素的交换，那么一般它就是不稳定的，因为这种交换可能导致相同的值前后关系改变。  
比如序列[10,8,3,10,6,1],在进行选择排序时(降序),元素1需要与第一个元素10进行交换，此时第一个元素10就排到了第二个元素10的后面，因此影响了稳定性。

## java系统中的排序算法
java.util.Arrays 中的sort()方法基于基本数据类型和引用类型设计了不同的排序方法  
### 1. 对于基本数据类型
采用**三向切分**的**快速排序**算法  
三向切分是在选择划分的值k后，把数组分为小于k，等于k和大于k的三部分，这种改进适应了含有大量重复数据的数组的排序，可以使复杂度逼近线型级别。
### 2. 对于引用类型数据
采用**归并排序**算法  
归并排序是稳定的排序算法，这在引用类型数据中是必要的，因为对象中可能存在其他有顺序意义的字段。  
但归并排序需要额外的空间进行过程中的存储，这里用空间换取了稳定性。