---
title: 设计模式 
author: ahou
layout: post
---
## 设计模式的原则
**参考文章: https://blog.csdn.net/itest_2016/article/details/77963818  
https://blog.csdn.net/a724888/article/details/72637636**  

#### 1. 开闭原则
对修改关闭，对扩展开启。  
#### 2. 面向接口原则
面向接口设计，而不是面向实现。降低耦合，可扩展性强。  
#### 3. 职责单一原则
一个类只负责一个功能领域的相应职责。  
#### 4. 迪米特法则
尽量减少一个模块和其他模块间的耦合，以减少对其他类的依赖。

## 创建型模式
作用是创建对象，提供多种创建对象的方式。  
包括简单工厂模式、工厂模式、抽象工厂模式、单例模式、建造者模式和原型模式。  
#### 1. 简单工厂模式
包含产品接口、具体产品和一个工厂类。一个工厂生产所有类型的产品。
#### 2. 工厂模式
包含产品接口、具体产品工厂接口和工厂类。有多个工厂类，每个工厂类对应生产一种产品。  
生产产品前先要选择需要的工厂。
#### 3. 抽象工厂模式
涉及到产品族时，产品之间可能存在兼容性问题，可以使用抽象工厂模式，一个工厂生产一族对应的产品。
#### 4. 单例模式
只实例化类的一个实例，每次返回该实例的引用。不用频繁新建实例，重复利用。  
 1) 饿汉模式:  初始化时就先把单例实例化，获取时直接返回单例即可。
 2) 懒汉模式:  与饿汉模式不同，懒汉模式下，类在实例化的时候才创建对象，不会存在内存的浪费。  
 但可能会出现线程安全问题，多个线程可能同时创建实例。**解决方法:**  
 - 通过synchronized关键字和双重校验

    ``` java
    public class Singleton {
        // 首先，也是先堵死 new Singleton() 这条路
        private Singleton() {}
        // 和饿汉模式相比，这边不需要先实例化出来，注意这里的 volatile，它是必须的
        private static volatile Singleton instance = null;
     
        public static Singleton getInstance() {
            if (instance == null) {
                // 加锁
                synchronized (Singleton.class) {
                    // 这一次判断也是必须的，不然会有并发问题
                    if (instance == null) {
                        instance = new Singleton();
                    }
                }
            }
            return instance;
        }
    }
    ```
    synchronized关键字的锁机制造成的性能较差。
    - 嵌套类方式
    

#### 5. 建造者模式
通常命名为xxxBuilder, 通过链式传递构造对象，给属性赋值。当有很多属性，有些需要设置，有些不设置时，会比较清晰。
#### 6. 原型模式