---
title: 算法
auther: ahou
layout: post
---

## 二分查找


## LRU
**参考文章：https://www.cnblogs.com/lzrabbit/p/3734850.html#f1**
LRU(least recent used) 最新最小使用
实现方式：
- LinkedHashMap，初始化中accessOrder 设置true，有大小限制时，可以重写removeEldestEntry(),在size大于设定值时返回true。
继承或者代理LinkedHashMap
- 链表+hashMap，自己维护。


## 平衡二叉搜索树 AVL  
**参考文章：https://blog.csdn.net/qq_34840129/article/details/80728186**  
普通二叉搜索树生成过程中，如果数据顺序插入，会造成树部分子树高度相差过大，深度过高影响效率。  
而平衡二叉树在生成过程中，会对树进行旋转，保证树的平衡性，即任意节点的左右子树高度差小于等于1。  
树的不平衡分为四种，分别标记为LL，RR，LR，RL。
- LL，节点a左子树较深，新插入节点位于a的左子树的左子树。此时进行**右旋**
- RR，节点a右子树较深，新插入节点位于a的右子树的右子树。此时进行**左旋**
- LR，节点a左子树较深，新插入节点位于a的左子树的右子树。此时先进行**左旋**（调整为LL），然后进行**右旋**
- RL，节点a右子树较深，新插入节点位于a的右子树的左子树。此时先进行**右旋**（调整为RR），然后进行**左旋**


## 红黑树
红黑树是可以实现高效查找的自平衡二叉树，二叉搜索树可以显著提高查找效率，但二叉树严重不平衡时其查找效率可能退化为链表，因此出现了平衡二叉树 AVL，红黑树等结构  
红黑树每个节点的最长子树不超过最短子树长度的两倍，而AVL树中要求更严格，每个节点最长子树与最短子树长度不超过1，相对于AVL，红黑树的调整会相对少，插入效率更高  

#### 红黑树性质
1. 节点分为红色和黑色
2. 根节点必为黑色
3. 叶子节点必为黑色且为null
4. 不会出现连续的红色节点，即红色节点子节点必为黑色节点
5. 从任意节点出发到它的叶子节点路径中黑色节点数目相等
6. 新建节点为红色节点（如果为黑色，新插入节点会导致5不满足，调整麻烦）

通过性质5和6可以保证红黑树的查找最差的路径长度不会超过最短路径的2倍，由于不会出现连续的红节点，最短的路径全为黑色节点，最长的应该是红黑相间，由于任意叶子节点到根节点的路径中黑色节点数目相等，那最短路径=n个黑色节点，最长路径=n个黑色节点+n个红色节点=2*最短路径

#### 红黑树的插入
插入节点为红色，当其父节点P也为红色时，违背性质4
这时候会有几种情况
1. 新插入节点N的叔叔U节点也为红色，P和U变为黑色，P和U的父节点G变为红色
2. 新插入节点N的叔叔节点U为黑色，这是需要进行旋转调整
    - 左左，P是其父节点G的左子节点，N是P的左子节点，右旋，P变黑，G变红即可
    - 左右，P是其父节点G的左子节点，N是P的右子节点，左旋变为**左左**，然后右旋调整
    - 右右，左左相反对应
    - 右左，左右相反对应
