---
title: Java-面试知识点
auther: ahou
layout: post
---
## 1. 内部类访问局部变量时，局部变量为何必须要通过final修饰

内部类如何实现访问局部变量?  
底层会将该变量作为**参数**传递给内部类构造函数。  
通过final修饰的原因是  
**保证数据的一致性**  
把变量修饰成final类型，在程序运行过程中不会被修改。因此final可以保证数据一致性，对于基本类型是指值的一致性，对于对象是指引用地址的一致性。  
防止变量在函数中被修改，而对象中使用旧的值造成的不一致现象。
因为内部类对象在使用局部变量时是把它当成同一个变量来使用的，并不知道其实使用的是一个传递过去的参数。

在JDK8中，可以不通过final修饰，这是一个语法糖，final通过底层加入。此时这个局部变量仍然无法修改，否则会报错。  

另一个解释是
**内部类可以访问到局部变量，而局部变量和内部类对象生命周期不一致之间的矛盾** 
局部变量在方法执行完毕后会被释放，而此时对象不一定，那么就会出现对象访问了一个不存在的变量。  
final修饰之后可以解决这一矛盾吗？好像不能
![enter description here](./images/1576982826098.png)  

参考博客：https://blog.csdn.net/tianjindong0804/article/details/81710268  


## 2. Synchronized 和 Lock的区别
Java 5之后, java.util.concurrent 提供了Lock接口和一些实现类来实现同步访问。它跟Java关键字synchronized都是通过加锁来实现同步访问，保障线程安全。
为了更好地使用它们，需要了解它们之间的区别。  

1. Lock是一个接口，而synchronized是Java的关键字,由内置语言实现。
2. synchronized的加锁和释放锁都是自动实现的；Lock需要手动加锁和释放锁，如果锁由于异常没有释放，容易导致死锁，一般需要在finally语句块中进行释放。
3. Lock具有更大的灵活性，意味着可以实现更多地功能。比如在多线程读写时，由于写操作和读写操作不能同时进行，如果通过synchronized加锁，那么在保证读写安全时，也限制了单纯的读操作也不能并行，实际上多线程多操作是不会出现线程安全问题的，而使用Lock接口就不会有这个问题，允许多线程读操作同时进行，ReadAndWriteLock类就是实现了相关锁的类。  
Lock可以让等待线程响应中断，超时退出等待，是否获得锁可以查询等，这些使用synchronized是不行的
4. 在Java6之前，synchronized是重量级的锁，锁操作的代价比较大，在一个线程获取锁后，其他竞争的线程会被阻塞直到获得锁。
synchronized被称作悲观锁，它认为线程之间总是存在竞争的，所以在遇到synchronized修饰的方法或代码块时，总是会加锁。
Lock是乐观锁，它假设线程之间是没有冲突的，如果有就通过CAS操作不断地尝试，直到成功获取锁。  
不过在Java6中，synchronized也进行了一些优化，加入了适应自旋，锁消除，锁粗化，轻量级锁，偏向锁等等。导致在Java6上synchronize的性能并不比Lock差。
![enter description here](./images/1577153141047.png)
**synchonized修饰静态方法时，锁对象是类本身，所有类的实例共用一把锁(所有类产生的对象共用这个静态方法)**

## ConcurrentHashMap是怎样实现线程安全的
在Java8之前，ConcurrentHashMap是通过将HashMap分段(Segment)，然后分别加锁来实现不同段的并发访问的。  
在Java8中，Segment仍然保留，但插入时使用了CAS操作。   


## 3. 什么是消息队列
消息队列首先是一种队列，其中用于存储信息。  
消息队列的使用有下面的好处。
1. 解耦
一般往消息队列中插入数据的叫做**生产者**，从消息队列取数据的叫做**消费者**。  
比如说存在生产者A和消费者B,C。在没有消息队列时，A需要向B和C传递数据，当B和C不再需要数据时，A的接口需要做相应的修改，或者消费者增加是要同时对新的消费者进行服务，这样维护会比较麻烦。  
当使用消息队列时，可以实现了生产者和消费者的解耦，A只需要把生产的数据放入消息队列，消费者也是从消息队列中获取数据，A不需要考虑其他消费者是否需要数据，消费者增加或减少。
2. 异步
当系统中不存在消息队列时，生产者产生的数据需要分别访问消费者的接口，然后才能继续接下来的任务，这是一种同步的工作方式，会影响生产者的工作效率。
3. 

