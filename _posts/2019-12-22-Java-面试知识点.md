---
title: Java-面试知识点
auther: ahou
layout: post
---
## 1. 内部类访问局部变量时，局部变量为何必须要通过final修饰

内部类如何实现访问局部变量?  
底层会将该变量作为**参数**传递给内部类构造函数。  
通过final修饰的原因是  
**保证数据的一致性**  
把变量修饰成final类型，在程序运行过程中不会被修改。因此final可以保证数据一致性，对于基本类型是指值的一致性，对于对象是指引用地址的一致性。  
防止变量在函数中被修改，而对象中使用旧的值造成的不一致现象。
因为内部类对象在使用局部变量时是把它当成同一个变量来使用的，并不知道其实使用的是一个传递过去的参数。

在JDK8中，可以不通过final修饰，这是一个语法糖，final通过底层加入。此时这个局部变量仍然无法修改，否则会报错。  

另一个解释是
**内部类可以访问到局部变量，而局部变量和内部类对象生命周期不一致之间的矛盾** 
局部变量在方法执行完毕后会被释放，而此时对象不一定，那么就会出现对象访问了一个不存在的变量。  
final修饰之后可以解决这一矛盾吗？好像不能
![enter description here](./images/1576982826098.png)  

参考博客：https://blog.csdn.net/tianjindong0804/article/details/81710268  


## 2. Synchronized 和 Lock的区别
Java 5之后, java.util.concurrent 提供了Lock接口和一些实现类来实现同步访问。它跟Java关键字synchronized都是通过加锁来实现同步访问，保障线程安全。
为了更好地使用它们，需要了解它们之间的区别。  

1. Lock是一个接口，而synchronized是Java的关键字,由内置语言实现。
2. synchronized的加锁和释放锁都是自动实现的；Lock需要手动加锁和释放锁，如果锁由于异常没有释放，容易导致死锁，一般需要在finally语句块中进行释放。
3. Lock具有更大的灵活性，意味着可以实现更多地功能。比如在多线程读写时，由于写操作和读写操作不能同时进行，如果通过synchronized加锁，那么在保证读写安全时，也限制了单纯的读操作也不能并行，实际上多线程多操作是不会出现线程安全问题的，而使用Lock接口就不会有这个问题，允许多线程读操作同时进行，ReadAndWriteLock类就是实现了相关锁的类。
4. 在Java6之前，synchronized是重量级的锁，锁操作的代价比较大，在一个线程获取锁后，其他竞争的线程会被阻塞直到获得锁。
synchronized被称作悲观锁，它认为线程之间总是存在竞争的，所以在遇到synchronized修饰的方法或代码块时，总是会加锁。
Lock是乐观锁，它假设线程之间是没有冲突的，如果有就通过CAS操作不断地尝试，直到成功获取锁。  
不过在Java6中，synchronized也进行了一些优化，加入了适应自旋，锁消除，锁粗化，轻量级锁，偏向锁等等。导致在Java6上synchronize的性能并不比Lock差。
