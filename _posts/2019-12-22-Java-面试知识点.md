---
title: Java-面试知识点
auther: ahou
layout: post
---



## 1. 内部类访问局部变量时，局部变量为何必须要通过final修饰

内部类如何实现访问局部变量?  
底层会将该变量作为**参数**传递给内部类构造函数。  
通过final修饰的原因是  
**保证数据的一致性**  
把变量修饰成final类型，在程序运行过程中不会被修改。因此final可以保证数据一致性，对于基本类型是指值的一致性，对于对象是指引用地址的一致性。  
防止变量在函数中被修改，而对象中使用旧的值造成的不一致现象。
因为内部类对象在使用局部变量时是把它当成同一个变量来使用的，并不知道其实使用的是一个传递过去的参数。

在JDK8中，可以不通过final修饰，这是一个语法糖，final通过底层加入。此时这个局部变量仍然无法修改，否则会报错。  

另一个解释是
**内部类可以访问到局部变量，而局部变量和内部类对象生命周期不一致之间的矛盾** 
局部变量在方法执行完毕后会被释放，而此时对象不一定，那么就会出现对象访问了一个不存在的变量。  
final修饰之后可以解决这一矛盾吗？好像不能
![enter description here](./images/1576982826098.png)  

参考博客：https://blog.csdn.net/tianjindong0804/article/details/81710268  




## 2. Synchronized 和 Lock的区别
Java 5之后, java.util.concurrent 提供了Lock接口和一些实现类来实现同步访问。它跟Java关键字synchronized都是通过加锁来实现同步访问，保障线程安全。
为了更好地使用它们，需要了解它们之间的区别。  

1. Lock是一个接口，而synchronized是Java的关键字,由内置语言实现。
2. synchronized的加锁和释放锁都是自动实现的；Lock需要手动加锁和释放锁，如果锁由于异常没有释放，容易导致死锁，一般需要在finally语句块中进行释放。
3. Lock具有更大的灵活性，意味着可以实现更多地功能。比如在多线程读写时，由于写操作和读写操作不能同时进行，如果通过synchronized加锁，那么在保证读写安全时，也限制了单纯的读操作也不能并行，实际上多线程多操作是不会出现线程安全问题的，而使用Lock接口就不会有这个问题，允许多线程读操作同时进行，ReadAndWriteLock类就是实现了相关锁的类。  
Lock可以让等待线程响应中断，超时退出等待，是否获得锁可以查询等，这些使用synchronized是不行的
4. 在Java6之前，synchronized是重量级的锁，锁操作的代价比较大，在一个线程获取锁后，其他竞争的线程会被阻塞直到获得锁。
synchronized被称作悲观锁，它认为线程之间总是存在竞争的，所以在遇到synchronized修饰的方法或代码块时，总是会加锁。
Lock是乐观锁，它假设线程之间是没有冲突的，如果有就通过CAS操作不断地尝试，直到成功获取锁。  
不过在Java6中，synchronized也进行了一些优化，加入了适应自旋，锁消除，锁粗化，轻量级锁，偏向锁等等。导致在Java6上synchronize的性能并不比Lock差。
![enter description here](./images/1577153141047.png)
**synchonized修饰静态方法时，锁对象是类本身，所有类的实例共用一把锁(所有类产生的对象共用这个静态方法)**

## ConcurrentHashMap是怎样实现线程安全的
在Java8之前，ConcurrentHashMap是通过将HashMap分段(Segment)，然后分别加锁来实现不同段的并发访问的。  
在Java8中，Segment仍然保留，但插入时使用了CAS操作。   




## 3. 什么是消息队列
**参考文章:  https://developer.51cto.com/art/201904/595020.htm**
消息队列首先是一种队列，其中用于存储信息。  

### 消息队列的使用有下面的好处
1. 解耦
一般往消息队列中插入数据的叫做**生产者**，从消息队列取数据的叫做**消费者**。  
比如说存在生产者A和消费者B,C。在没有消息队列时，A需要向B和C传递数据，当B和C不再需要数据时，A的接口需要做相应的修改，或者消费者增加是要同时对新的消费者进行服务，这样维护会比较麻烦。  
当使用消息队列时，可以实现了生产者和消费者的解耦，A只需要把生产的数据放入消息队列，消费者也是从消息队列中获取数据，A不需要考虑其他消费者是否需要数据，消费者增加或减少。

2. 异步
当系统中不存在消息队列时，生产者产生的数据需要分别访问消费者的接口，然后才能继续接下来的任务，这是一种同步的工作方式，会影响生产者的工作效率。  
使用消息队列后，A只需要生产数据，放到消息队列中，然后就接着执行后面的任务，不需要调用B，C的接口等待结果。
实现更高的吞吐量。

3. 削峰,限流
当系统处理高并发访问时,如果不存在消息队列，所有访问直接通向处理的系统，如果访问超过系统最大负荷的话会使系统崩溃。  
如果我们把任务放到消息队列中，那么系统就只需要根据自己的处理能力来处理访问，刻意处理任务就从消息队列中获取数据。在高并发访问时仍然能够正常的工作。

### 为啥要实现消息队列中间件
Java中已经提供了许多种队列实现，我们仍然要实现消息队列中间件的原因  
1. 高可用
为了保证队列的可靠性，不能使用单机的消息队列，否则该系统故障后，整个系统无法工作。消息队列需要集群/分布式。
2. 数据丢失问题
为了防止数据丢失，我们需要实现数据的存储，当系统崩溃时不至于丢失数据。
3. 消费者获取队列方式
A提醒消费者获取还是消费者主动查询，有数据便获取。

这些都是消息队列需要考虑的问题，而Java的实现不能满足如此复杂的需求。
