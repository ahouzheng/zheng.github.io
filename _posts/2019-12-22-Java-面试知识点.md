---
title: Java-面试知识点
auther: ahou
layout: post
---



## 1. 内部类访问局部变量时，局部变量为何必须要通过final修饰

内部类如何实现访问局部变量?  
底层会将该变量作为**参数**传递给内部类构造函数。  
如果编译期可以确定变量的值则直接在匿名内部类中创建拷贝；如果不能确定则以参数进行传递。
**参考文章: https://www.runoob.com/w3cnote/java-inner-class-intro.html**  
  
通过final修饰的原因是  
**保证数据的一致性**  
把变量修饰成final类型，在程序运行过程中不会被修改。因此final可以保证数据一致性，对于基本类型是指值的一致性，对于对象是指引用地址的一致性。  
防止变量在函数中被修改，而对象中使用旧的值造成的不一致现象。  
因为内部类对象在使用局部变量时是把它当成同一个变量来使用的，并不知道其实使用的是一个传递过去的参数。  

在JDK8中，可以不通过final修饰，这是一个语法糖，final通过底层加入。此时这个局部变量仍然无法修改，否则会报错。  

另一个解释是
**内部类可以访问到局部变量，而局部变量和内部类对象生命周期不一致之间的矛盾** 
局部变量在方法执行完毕后会被释放，而此时对象不一定，那么就会出现对象访问了一个不存在的变量。  
final修饰之后可以解决这一矛盾吗？好像不能
![enter description here](./images/1576982826098.png)  

参考博客：https://blog.csdn.net/tianjindong0804/article/details/81710268  




## 2. Synchronized 和 Lock的区别
Java 5之后, java.util.concurrent 提供了Lock接口和一些实现类来实现同步访问。它跟Java关键字synchronized都是通过加锁来实现同步访问，保障线程安全。
为了更好地使用它们，需要了解它们之间的区别。  

1. Lock是一个接口，而synchronized是Java的关键字,由内置语言实现。  
 
2. synchronized的加锁和释放锁都是自动实现的；Lock需要手动加锁和释放锁，如果锁由于异常没有释放，容易导致死锁，一般需要在finally语句块中进行释放。  

3. Lock具有更大的灵活性，意味着可以实现更多地功能。比如在多线程读写时，由于写操作和读写操作不能同时进行，如果通过synchronized加锁，那么在保证读写安全时，也限制了单纯的读操作也不能并行，实际上多线程多操作是不会出现线程安全问题的，而使用Lock接口就不会有这个问题，允许多线程读操作同时进行，ReadAndWriteLock类就是实现了相关锁的类。  
Lock可以让等待线程响应中断，超时退出等待，是否获得锁可以查询等，这些使用synchronized是不行的  

4. 在Java6之前，synchronized是重量级的锁，锁操作的代价比较大，在一个线程获取锁后，其他竞争的线程会被阻塞直到获得锁。
synchronized被称作悲观锁，它认为线程之间总是存在竞争的，所以在遇到synchronized修饰的方法或代码块时，总是会加锁。
Lock是乐观锁，它假设线程之间是没有冲突的，如果有就通过CAS操作不断地尝试，直到成功获取锁。  
不过在Java6中，synchronized也进行了一些优化，加入了适应自旋，锁消除，锁粗化，轻量级锁，偏向锁等等。导致在Java6上synchronize的性能并不比Lock差。
![enter description here](./images/1577153141047.png)
**synchonized修饰静态方法时，锁对象是类本身，所有类的实例共用一把锁(所有类产生的对象共用这个静态方法)**

## 3. ConcurrentHashMap是怎样实现线程安全的
在Java8之前，ConcurrentHashMap是通过将HashMap分段(Segment)，然后分别加锁来实现不同段的并发访问的。  
在Java8中，Segment仍然保留，但插入时使用了CAS操作。   




## 4. 什么是消息队列
**参考文章:  https://developer.51cto.com/art/201904/595020.htm**
消息队列首先是一种队列，其中用于存储信息。  

### 消息队列的使用有下面的好处
1. 解耦
一般往消息队列中插入数据的叫做**生产者**，从消息队列取数据的叫做**消费者**。  
比如说存在生产者A和消费者B,C。在没有消息队列时，A需要向B和C传递数据，当B和C不再需要数据时，A的接口需要做相应的修改，或者消费者增加是要同时对新的消费者进行服务，这样维护会比较麻烦。  
当使用消息队列时，可以实现了生产者和消费者的解耦，A只需要把生产的数据放入消息队列，消费者也是从消息队列中获取数据，A不需要考虑其他消费者是否需要数据，消费者增加或减少。

2. 异步
当系统中不存在消息队列时，生产者产生的数据需要分别访问消费者的接口，然后才能继续接下来的任务，这是一种同步的工作方式，会影响生产者的工作效率。  
使用消息队列后，A只需要生产数据，放到消息队列中，然后就接着执行后面的任务，不需要调用B，C的接口等待结果。
实现更高的吞吐量。

3. 削峰,限流
当系统处理高并发访问时,如果不存在消息队列，所有访问直接通向处理的系统，如果访问超过系统最大负荷的话会使系统崩溃。  
如果我们把任务放到消息队列中，那么系统就只需要根据自己的处理能力来处理访问，刻意处理任务就从消息队列中获取数据。在高并发访问时仍然能够正常的工作。  
服务器的软件**负载均衡**就是通过分发消息队列来实现的。

### 为啥要实现消息队列中间件
Java中已经提供了许多种队列实现，我们仍然要实现消息队列中间件的原因  
1. 高可用
为了保证队列的可靠性，不能使用单机的消息队列，否则该系统故障后，整个系统无法工作。消息队列需要集群/分布式。
2. 数据丢失问题
为了防止数据丢失，我们需要实现数据的存储，当系统崩溃时不至于丢失数据。
3. 消费者获取队列方式
A提醒消费者获取还是消费者主动查询，有数据便获取。

这些都是消息队列需要考虑的问题，而Java的队列实现不能满足如此复杂的需求。


## 5. HashMap什么时候需要重写hashcode和equals
**参考文章:https://www.cnblogs.com/yangqiong1989/p/10795049.html**  
**Object源码中有hashcode实现原则**  
当HashMap需要使用自定义的类作为键的时候，或者对象当前的hashcode值。  
默认的类方法中equals和hashcode(native 方法)继承自object，equals是比较对象引用是否相等  

同时hashcode的实现有下面三个原则：
#### 1. 同一个应用程序，在一次执行中，多次计算同一个对象的hashcode值必须相等。在多次执行应用程序，返回的hashcode不要求相等。
#### 2. equals相等的对象，hashcode值必须相等。
#### 3. equals不相等的对象，hashcode值不必一定不同。但equals不相等的对象具有不同的hashcode表示有很好的散列性能。

**由原则2可知，原来的hashcode只能保证在对象equals相等，即引用地址相同时才返回相同的hash值。**  

当不同引用的对象具有相同的某些属性值时，我们在hash时一般需要把他们映射到同一个hashcode上，这时需要重写hashcode方法来实现。如果我们只重写hashcode而不重写equals，会导致第二个原则无法满足。所以应该同时重写hashcode和equals，保持equals和hashcode在使用的属性上保持一致。

Java.util.HashCode在put元素时，首先根据hashcode值与一个设定值异或来将它对应到数组索引处，如果该位置上没有元素，则直接作为链表节点插入；如果该位置有对象，判断hashcode是否相同，如果相同，判断equals是否相同，形同则进行值的更新，不相等则插入到链表的首部。

## 5. ArrayList和LinkedList底层实现有什么差别？它们各自适用于哪些场合？

ArrayList底层通过动态数组实现，LinkedList底层是通过双向链表来实现，
这意味着ArrayList在按索引查找上可以实现O(1)的时间复杂度，而基于数组实现表示增加和删除元素代价相对较高。倒台数组是指，当数组中的元素查过一定的阈值时，还需要对数组进行扩容，此时需要将整个List的元素进行迁移。
## **增加具体的扩容数据**  
而LinkedList在增加和删除元素时相对便捷，只需要修改链表的指针即可，同时不存在扩容操作，避免了扩容时元素的迁移。但基于链表的查找操作需要遍历链表，时间复杂度是O(N)。不过由于LinkedList是基于双向链表，并且保存有链表收尾的指针，在按索引查找时可以选择从头还是尾来开始遍历，所以最多只需要遍历一半的元素。  
从它们各自的特点上，我们可以分析它们的使用场合，ArrayList适用于有大量索引查找操作，并且一般从末端插入的场景。
而LinkedList适用于有比较多的插入，删除操作场景。  

同时LinkedList还继承了Deque接口，有更大的灵活性，可以作为单端和双端队列使用，还可以作为栈。
但用于栈或队列时，推荐使用ArrayDeque，它拥有比LinkedList更好的性能(当作栈或队列使用时)。
因为ArrayDeque底层是基于循环数组实现的，对于栈和队列这种只在首尾操作元素的数据结构，基于数组的实现访问是常量的时间复杂度，省去了链表中把对象包装成节点的操作。

## 6. java异常

![enter description here](./images/exception.jpg)
java异常继承自超类 Throwable，分为Error和Exception
其中Error包括内存溢出等，由虚拟机处理
Exception分为RuntimeException和一般异常
#### 1.可查异常和不可查异常  
不可查异常指RuntimeException及其子类和Error,这些异常在我们的程序中可以不处理，在异常出现时会从方法中逐层抛出，最后退出线程或主线程。
可查异常,除RuntimeException类之外，其他的Exception及其子类都属于可查异常，这是我们必需要处理的异常，需要用try,catch语句捕获或者抛出，否则无法通过编译

#### 2. 运行时异常和非运行时异常
运行时异常是指RuntimeException及其子类，不严格要求特别的处理
非运行时异常，可查异常

## 7. & 与 &&
&& 表示逻辑与  
& 表示按位与和逻辑与  
表示逻辑与时，&是长路与，两个逻辑量都会判断  
&&是短路与，如果第一个是false，则不判断第二个逻辑量，直接返回false  

## 8. HashMap 与 HashTable
源码中的一句话
``` java
 * (The {@code HashMap} class is roughly equivalent to {@code Hashtable}, except that it is
 * unsynchronized and permits nulls.)
```
HashMap不是线程安全的，且允许key和value中出现null  
HashTable是线程安全的，不允许null  

## 9. 幻读
SQL中对幻读的定义: 在两个连续的查找之间一个并发的修改事务修改了查询的数据集，导致这两个查询返回了不同的结果  
解决方法: 提高事务隔离级别为Serializable(串行化)

## 10. java是单继承，多实现。 多继承有什么不好
**参考博客：https://blog.csdn.net/u014133299/article/details/77571912**
如果A和B类都有方法fun，但是有不同的实现。  
当C同时继承A和B，当它调用fun方法时，由于A和B中的实现不一致，会出现歧义  
使用多实现时，由于接口不包含方法具体的实现，不会出现这种矛盾。

## 11. abstract class 和 interface的区别

抽象类是通过被继承被使用 extends  
接口是通过实现被使用  implements  
  
抽象类是通过继承使用，所以一个类只能继承一个抽象类  
而一个类可以同时实现多个接口  
  
抽象类中可以有实例变量  
接口中只能有类变量(通过static修饰的变量)  
  
抽象类中可以实现方法，而接口中的方法没有实现。  
在java8中，接口中也允许实现方法，在方法前需要用default修饰，这种用法在java8中已经被广泛使用，比如List接口中的sort()方法  
对接口的这一改变会带来多继承中可能出现的一个问题，即继承的多个接口中有同一个方法的不同实现，会出现歧义。  
为避免这一情况，java中加入了以下的规则：  
**参考文章: https://www.cnblogs.com/sum-41/p/10878807.html**   
1. 类中的方法优先级最高，类或父类中声明的方法优先级高于任何声明为默认方法的优先级  
2. 在第一条无法判断时，子接口的优先级更高： 选择根据题的实现，认为继承的子接口中实现更具体  
3. 第二条也无法判断时，继承多个接口的类必须通过显式覆盖和调用期望的方法，显式的选择使用某一个默认方法  
第三条实现的方式：
``` java
public class c implements A, B{
// A和B接口都实现了hello() 方法，并且A和B 没有继承关系，此时需要在C中显式的覆盖方法hello来指名期望方法或者自己实现
    public void hello(){
        B.super.hello();
    }
// 或者C自己实现
//    public void hello(){
//        System.out.println("Hello C");
//    }
}
```

