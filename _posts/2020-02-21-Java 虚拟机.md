---
title: Java 虚拟机
auther: ahou
layout: post
---

## Java内存区域

## 垃圾收集 GC

#### 垃圾收集器
新生代收集器 Serial复制  ParNew复制  Parallel scavenge复制  
老年代收集器 Serial Old标记-整理  parellel Old标记-整理 CMS标记-清除  
可以同时对新生代和老年代进行回收 G1  

**Parallel scavenge：** 
CMS和其他收集器都是尽量减少停顿时间，更适合与应用交互的场景。  
Parallel scavenge主要的关注点是达到可控制的吞吐量，吞吐量是指(cpu执行用户线程的时间)/(cpu执行用户线程的时间+垃圾收集的时间=cpu的实际运行时间)，更适合做后台运算。  
它提供两个参数用来控制最大的垃圾收集时间和直接设置吞吐量大小  


对运行在client模式下的虚拟机，serial是默认的新生代来及收集器。  
serial Old是serial的老年代版本，用于对老年代的对象进行收集，它主要在client模式中实现垃圾收集，在server模式下，它可以与parallel scavenge配合使用，还作为CMS收集器的后背预案。

**CMS：**  
CMS是以实现最小停顿时间为目标的垃圾收集器，采用的是标记-清除算法，收集过程分为四步  
- 初始标记  标记GC roots能直接关联的对象，速度很快
- 并发标记  进行GC roots tracking
- 重新标记  标记在并发标记阶段导致标记变动的对象
- 并发清除
只在初始标记和重新标记阶段会发生STW，并且这两个过程耗时很短。  
CMS算法的缺点是
- 对CPU资源敏感，默认使用回收线程数是(CPU数量+3)/4,其回收线程数由cpu数来决定
- 无法处理浮动垃圾，在并发清除阶段也会产生垃圾，这些垃圾只能在下一次进行清理。可能会因此出现 concurrent mode failure而导致full GC的发生。
- 采用标记-清除，会导致内存碎片，如果找不到足够大的连续内存分配对象，也会触发full GC

由于会产生浮动垃圾，所以CMS不能登老年代满了之后再收集，需要在达到一定的比例之后就开始收集，如果在收集期间预留的老年代空间不足以存放浮动垃圾，则会产生concurrent mode failuer，这时候启动serial old进行收集，导致STW

**G1：**  
面向服务端的收集器，它也可以与应用程序并行执行。
与CMS相比：
- 采用标记-整理算法，不会产生内存碎片
- 建立了可预测的停顿时间模型，可以将停顿时间控制在用户设定的时间之内
G1能建立可预测的停顿时间模型，是因为它对堆空间的分配与传统的新生代老年代不同，传统的新老生代分配内存都是连续的，而G1收集器各代的存储地址是不连续的，每一代都使用n个大小相同的不连续的Region，还分配了H区用于存储大的对象，直接进入老年代。  

G1收集器对这些region分别计算垃圾收集价值（回收能得到的空间及回收的一些经验数据），维护一个优先列表，在进行需要进行垃圾收集时，根据设定的收集时间，优先选择收集价值大的region，而不是像full GC一样对所有区域进行收集

它的收集过程：
- 初始标记
- 并发标记
- 重新标记
- 筛选回收



**垃圾收集中stop the world与safe point:**   
在full GC与minor GC中都会出现stop the world，此时只有垃圾收集线程在工作，会造成服务的停止。  
stop the world不会随时进行，它发生在safe point，只在确定安全时才进行，安全点的主要位置有
- 循环的末尾
- 方法返回前
- 调用方法的call之后，也就是方法执行前
- 抛出异常的位置

## 类加载过程

## 类加载器

## Java内存模型
