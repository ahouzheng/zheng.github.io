---
title: Java 虚拟机
auther: ahou
layout: post
---

## Java内存区域

## 垃圾收集 GC

#### 垃圾收集器
新生代收集器 Serial复制  ParNew复制  Parallel scavenge复制  
老年代收集器 Serial Old标记-整理  parellel Old标记-整理 CMS标记-清除  
可以同时对新生代和老年代进行回收 G1  

**Parallel scavenge：** 
CMS和其他收集器都是尽量减少停顿时间，更适合与应用交互的场景。  
Parallel scavenge主要的关注点是达到可控制的吞吐量，吞吐量是指(cpu执行用户线程的时间)/(cpu执行用户线程的时间+垃圾收集的时间=cpu的实际运行时间)，更适合做后台运算。  
它提供两个参数用来控制最大的垃圾收集时间和直接设置吞吐量大小  


对运行在client模式下的虚拟机，serial是默认的新生代来及收集器。  
serial Old是serial的老年代版本，用于对老年代的对象进行收集，它主要在client模式中实现垃圾收集，在server模式下，它可以与parallel scavenge配合使用，还作为CMS收集器的后背预案。

**CMS：**  
CMS是以实现最小停顿时间为目标的垃圾收集器，采用的是标记-清除算法，收集过程分为四步  
- 初始标记  标记GC roots能直接关联的对象，速度很快
- 并发标记  进行GC roots tracking
- 重新标记  标记在并发标记阶段导致标记变动的对象
- 并发清除
只在初始标记和重新标记阶段会发生STW，并且这两个过程耗时很短。  
CMS算法的缺点是
- 对CPU资源敏感，默认使用回收线程数是(CPU数量+3)/4,其回收线程数由cpu数来决定
- 无法处理浮动垃圾，在并发清除阶段也会产生垃圾，这些垃圾只能在下一次进行清理。可能会因此出现 concurrent mode failure而导致full GC的发生。
- 采用标记-清除，会导致内存碎片，如果找不到足够大的连续内存分配对象，也会触发full GC

由于会产生浮动垃圾，所以CMS不能登老年代满了之后再收集，需要在达到一定的比例之后就开始收集，如果在收集期间预留的老年代空间不足以存放浮动垃圾，则会产生concurrent mode failuer，这时候启动serial old进行收集，导致STW

**G1：**  
面向服务端的收集器，它也可以与应用程序并行执行。整体上看采用标记-整理算法，region之间看是复制算法。
与CMS相比：
- 采用标记-整理算法，不会产生内存碎片
- 建立了可预测的停顿时间模型，可以将停顿时间控制在用户设定的时间之内
G1能建立可预测的停顿时间模型，是因为它对堆空间的分配与传统的新生代老年代不同，传统的新老生代分配内存都是连续的，而G1收集器各代的存储地址是不连续的，每一代都使用n个大小相同的不连续的Region，还分配了H区用于存储大的对象，直接进入老年代。  

G1收集器对这些region分别计算垃圾收集价值（回收能得到的空间及回收的一些经验数据），维护一个优先列表，在进行需要进行垃圾收集时，根据设定的收集时间，优先选择收集价值大的region，而不是像full GC一样对所有区域进行收集

它的收集过程：
- 初始标记
- 并发标记
- 重新标记
- 筛选回收  在该阶段对各region的回收价值和成本进行排序筛选。然后回收
其中只有并发标记是与工作线程同时进行的

**垃圾收集中stop the world与safe point:**   
在full GC与minor GC中都会出现stop the world，此时只有垃圾收集线程在工作，会造成服务的停止。  
stop the world不会随时进行，它发生在safe point，只在确定安全时才进行，安全点的主要位置有
- 循环的末尾
- 方法返回前
- 调用方法的call之后，也就是方法执行前
- 抛出异常的位置

## Java对象创建  内存布局  访问定位
**参考文章:[Java内存区域](https://github.com/Snailclimb/JavaGuide/blob/3965c02cc0f294b0bd3580df4868d5e396959e2e/Java%E7%9B%B8%E5%85%B3/%E5%8F%AF%E8%83%BD%E6%98%AF%E6%8A%8AJava%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E8%AE%B2%E7%9A%84%E6%9C%80%E6%B8%85%E6%A5%9A%E7%9A%84%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0.md)**  
#### 1. Java对象创建的五个过程
**类加载检查:** JVM在new一个对象的时候，根据指令参数检查常量池中的符号引用。确定对象的类是否已经被加载、解析和初始化过。  

**内存分配:** 通过类加载检查之后，虚拟机开始为对象分配内存，对象所需的内存此时已经是确定的。分配内存的方法有**指针碰撞**和**空闲列表**两种，具体使用哪种要根据使用的垃圾收集算法来确定，因为垃圾收集算法决定了内存是否规整。  
如果使用“**标记-清除**”算法，那么内存是不规整的，需要使用空闲列表方式，该方式维护了一个标记可用内存的空闲列表，虚拟机从中选择一个连续的足够大的内容区域分配给对象。  
如果使用**复制或标记-整理**算法，一次垃圾收集中，把不需要清理的对象全部移动到另一部分内存区域中。此时内存是规整的，可以使用指针碰撞方式，直接将没使用的内存区域指针移动一部分分配给对象。  
内存分配可能存在线程安全的问题，hotspot虚拟机通过**TLAB**和**CAS+失败重试**来为对象分配内存，保证对象的分配是线程安全的，TLAB是虚拟机为每一个线程在Java堆中分配了一段内存，当TLAB内存用尽时，再通过“CAS+失败重试”来为对象分配内存。

**初始化零值:** 该过程把分配的内存区域清零，这样可以保证生成的对象参数都有零值，不需要赋初值就可以直接使用。  

**设置对象头:** 对象初始化零值之后，要设置对象头信息，其中包括对象所属的类、如何找到该类、对象哈希值、分代年龄信息等，还有对象锁信息。  

**执行init:** 以上工作完成之后，从虚拟机的视角来说，一个对象已经完成了，接下来会执行init方法，根据Java代码对对象进行初始化。 该init方法包含对象父类的属性初始化、语句块、构造函数和该类的属性初始化、语句块、构造函数。  

#### 2. 对象的内存布局
Java对象占用的内存可以分为三个部分  
**对象头:** 该部分存储对象所属的类、如何找到该类、对象哈希值、分代年龄和是否加锁等信息。  
**实例数据部分:** 这部分存储的才是对象的属性等实际信息。  
**对齐部分:** hotspot虚拟机要求对象的总内存需要是8字节的整数倍，否则需要进行对齐占位。  

#### 3. 对象的访问定位
Java实例变量中存储的是对象的reference，访问时根据reference定位Java堆中实际的对象，定位的方式根据使用的虚拟机不同，主要有两种：  
- 句柄方式：每一个对象都在堆中创建一个句柄，存储对象的实际地址和到对象类型数据的指针(指向方法区)，然后再根据实际地址访问堆中的对象。
 ![enter description here](./images/1581947427388.png)
- 直接访问：reference直接指向堆中的对象地址，无需通过句柄再次定位，但堆中需要分配位置存储类信息地址
 ![enter description here](./images/1581947443743.png)
**这两种方式各有优势，直接访问的访问速度更快，省去了句柄中的一次访问，但每次堆中对象位置改变都要更新reference的值，而句柄方式中修改句柄中的地址即可，reference指向的是稳定的句柄地址，更方便**  
**Sun hotspot虚拟机采用直接访问方式定位对象**  


## 类加载过程
**参考文章：https://baijiahao.baidu.com/s?id=1636309817155065432&wfr=spider&for=pc**

类的加载分为加载，验证，解析，准备，初始化5个阶段  
验证，解析，准备同一叫做连接阶段  
加载，验证，准备，初始化的顺序不会改变，但解析发生的阶段不是固定的。  

- 加载
通过类的**全限定名**找到对应的**二进制流**文件  
将文件中的**静态存储结构**转换为**方法区**中的数据结构
在**堆中**生成Class对象，作为方法区中类数据的访问入口
- 验证
进行class文件的验证，保证文件能被虚拟机正确加载且不会对虚拟机造成危害
验证过程分为文件格式验证，元数据验证，字节码验证，符号引用验证  
文件格式验证：.class文件是否符合class文件的格式（魔数等），还有当前虚拟机的版本是否符合要求  
元数据验证：是否有父类，父类是否可继承，是否实现了父类或接口要求实现的方法，是否访问父类中不允许访问的成员  
字节码验证：这个阶段主要进行字节码中的语句验证，确定语句是否合法，符合逻辑，保证跳转指令不会调转到方法体以外  
符号引用验证：在解析阶段进行，确保符号引用可以被正确转化为直接引用

- 解析
把符号引用转换为直接引用，符号引用中存储的是字面量，用来标识目标和无歧义的定位到目标，而直接引用用于指向实际的对象。
- 准备
准备阶段生成类变量（静态变量），此时类变量中的值是零值，类变量赋初值的过程在初始化阶段进行
- 初始化
该阶段执行类构造器<cinit()>方法对类进行初始化，cinit方法中收敛了静态变量赋初值的语句，同时还有静态语句块中的内容，会根据声明顺序调用这些语句来完成类的初始化

## ClassLoader与双亲委派模型
**参考文章：https://blog.csdn.net/briblue/article/details/54973413**  

ClassLoad是指类加载器，器作用是把.class中的类加载到虚拟机中   
Java中自带有三个类加载器，**它们都是加载指定路径下的类**：  
- Bootstrap ClassLoader 启动类加载器，最顶层的加载器，用本地代码实现的加载器，负责加载%JAVA_HOME%/jre/lib下的核心类库如rt.jar,resources.jar,charset.jar等。另外需要注意的是可以通过启动jvm时指定-Xbootclasspath和路径来改变Bootstrap ClassLoader的加载目录。
- ExtClassLoader，扩展类加载器，负责加载%JAVA_HOME%/jre/lib/ext下的jar包和class文件
- AppClassLoader，系统类加载器，负责加载应用程序的类
其中Bootstrap ClassLoader是c++代码实现的，它是虚拟机的一部分，其他两个加载器是java类
它们的运行顺序是Bootstrap ClassLoader-》Extention ClassLoader-》AppClassLoader

**自定义加载器：**  
重写findClass()方法，在父类加载器不能加载时，调用该方法查找类

**双亲委派模型:**
当类加载器收到类加载请求时，它首先将加载请求传递给父加载器去加载，最终所有类加载请求都会传递到Bootstrap ClassLoader中，当父加载器无法加载时，子加载器才尝试进行加载。

**contextClassLoader：**  
**参考文章：https://blog.csdn.net/justloveyou_/article/details/72231425
https://blog.csdn.net/yangcheng33/article/details/52631940**  

上下文类加载器，线程Thread中的一个属性，该属性的加入是违背双亲委派模型的。它的加入增加了类加载的灵活性
**适用场景：**
- SPI中接口是在启动类加载器中加载，但启动类加载器无法加载实现类，SPI接口中需要类的实例，这时候可以调用上下文加载器加载
- 高层提供接口，在低层去实现，而在高层中有需要实现类的实例的时候，需要线程上下文加载器帮助高层ClassLoader加载低层中的类
- Spring为多个WEB-app管理bean，在加载时调用不同app自己的上下文加载器来加载其类，实现应用之间的隔离


## Java内存模型
