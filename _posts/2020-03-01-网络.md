---
title: 网络
auther: ahou
layout:post
---

## 网络5层和7层模型
应用层（http），传输层（TCP，UDP），网络层（IP），链路层（以太网），物理层
应用层（http），表示层（数据编码与加密），会话层，传输层（TCP，UDP），网络层（IP），链路层（以太网），物理层

## TCP和UDP的区别
- UDP只提供基本的数据传输服务和有限的校验，TCP提供可靠数据传输
- TCP是有连接的，UDP无连接。
- UDP不保证数据的有序性和可靠传输，TCP可以保证有序性和数据可靠传输，通过序号，重传控制，校验和等手段保证这些性质
- TCP占用资源高于UDP，传输速度慢于UDP，UDP适用于要求高速传输的通信场合，比如网络视频会议，在线游戏等
- TCP是点对点通信，UDP可以实现一对一，一对多通信。
- TCP是面向字节流的数据传输，UDP是面向数据报的数据传输

## TCP为什么是面向流的传输协议
UDP是面向报文的数据传输，原因是UDP从应用层接收到一个数据报，不管数据报的长度多大都放到一个UDP报文中进行传输  
TCP在接收到应用层数据报后，会根据情况将数据按照字节进行拆分，按照顺序包裹到多个TCP报文中进行传输，也就是报数据当成字节流来看待，而不以应用层的数据报为传输单位  
同时在接收端存在缓冲区，当接收端收到足够多个的连续TCP报文后，再进行加载处理，保证报文的有序性。


## TCP三次握手和四次挥手
**参考文章：https://blog.csdn.net/qq_38950316/article/details/81087809**

**TCP主要首部信息：**  
- 源端口和目的端口，对应发送和接受方应用程序
- 序号seq和确认号ack，存放数据序号（标记数据段传输顺序）和确认号（一般是将收到的序号+1）
- 标志位 SYN，ACK，FIN等，仅在ACK为1时，确认号才有效
- 校验值

**三次握手：**  
首先客户端向服务端发送连接请求，SYN置1，带有序列号seq=x，然后状态变为SYN_SEND  
服务端收到请求后，创建连接，进行响应，SYN置1，ACK置1，带有序列号seq=y,确认号ack=x+1，然后状态变为SYN_REVD  
客户端收到响应后，ACK置1，发送序列号seq=x+1，确认号ack=y+1，然后状态变为established  
服务端收到信息后，状态变为established，连接完全建立

**为什么是三次握手：**  
- 三次握手可以保证服务端和客户端都可以确定对方能够正常的收发数据  
首先客户端向服务端发送一次数据，然后服务端进行响应，在这两次握手之后，客户端就可以确定服务端可以正常的收发数据，而服务端只收到了客户端数据，只能确定客户端可正常发送数据，不确定他是否可以正常接收自己的数据，所以需要第三次握手，客户端对服务端进行响应，服务端才能确定客户端的正常收发功能。  
- 三次握手可以防止无效连接，如果客户端向服务端发送的第一个连接请求因为较大延时没有及时到达服务端，客户端有重新发送连接请求，然后建立连接，这时第一个连接请求到达服务端，服务端以为是另一个连接请求，确认后新建了一个连接，但此时客户端已经放弃了这个连接，此时服务端的资源就被浪费了，如果是三次握手，客户端不返回确认就不会建立连接。



**四次挥手：**  
当客户端想要终止连接时  
首先客户端发送终止连接请求，使FIN置1，带有序列号seq=u,然后状态变为FIN_WAIT1  
服务端收到终止连接的请求后进行响应，使ACK置1，带有确认号ack=u+1和序列号seq=v，然后状态变为CLOSE_WAIT，客户端收到信息后状态变为FIN_WAIT2  
之后服务端在确定可以关闭连接时，发送关闭连接信息，使FIN和ACK置1，带有确认号ack=u+1和序列号seq=w，然后状态变为LAST_ACK  
客户端收到信息后，发送响应，使ACK置1, 带有确认号ack=w+1和序列号seq=u+1，然后进行入TIME_WAIT等待2个MSL(最长报文段寿命)后closed连接，服务端收到连接后状态立即变为closed  
一般服务端结束连接的时间要早于客户端  

**为什么客户端发送第二个报文段后还要等待2MSL：**  
为了保证连接的正常关闭，需要考虑最后的ack报文可能不能正常发送，如果服务端收不到响应，会重发FIN报文，此时客户端再次发送ACK，然后等待2MSL。MSL（maximum segment lifetime）是报文段的最长寿命，等待2MSL就是一个发送时间和一个回复时间。

**为什么握手是三次，而挥手要四次：**  
在握手时，服务端收到SYN请求时，会直接返回SYN+ACK响应，但在终止连接时，服务端还有未发送完毕的数据，所以只能先回复ACK数据包，等数据发送完毕后，再发送FIN数据包，所以要多一次通信。


## Http
**参考文章：https://www.cnblogs.com/rencoo/p/11940100.html**
http报文分为请求报文request和响应报文response，报文组成为  
报文首部，报文主体  
请求报文首部包含
- 请求行，请求方法，url，http版本
- 首部字段

#### Http报文首部有哪些属性（首部字段）
- cache-control 缓存控制
- connection 连接类型
- keep-alive 保持连接时间
- set-cookie 设置cookie

- content-Type:text/html，表示报文主题的对象类型
- Content-Encoding 
- Content-Language
- Content-Length

- Transfer-Encoding， 报文传输的编码类型
- Accept-Charset 有限使用的字符集
- Accept-Coding 优先内容编码
- Accept-Language 优先语言，自然语言
- host，请求资源所在服务器
- Referer：发出请求的页面的URL
- user-agent 用户代理


## cookie，session和token
cookie用于记录用户访问信息，存储在用户端。每次访问对应的域时需要带上cookie，cookie存储的信息会造成网络传输上的负担。  
session可以减轻这种情况，客户端向服务端发起请求后，服务端会建立一个session（会话），存储客户的访问信息，这样在cookie中只需存储一个JSESSIONID信息，服务器收到该ID便可确认客户的身份，session是存储在服务端的。  
**区别：**
- cookie存储在客户端，session存储在服务器上
- cookie不是很安全，可能被截获分析
- session适合保存复杂的数据类型，而cookie是保存ascii码，保存复杂内容不太方便

客户端禁止cookie时，为了表示客户端，会使用url重写，在url增加后sid=xxx
session可以放在文件，内存或数据库中。  
TOMCAT中session在不活跃时默认生命周期是30分钟  

** 参考文章：https://www.cnblogs.com/moyand/p/9047978.html**
在使用session是，服务器需要保存所有的session ID，在集群服务中还存在session id的共享问题  
token可以解决这个问题，服务器不需要再存储session id，而是给登录后的用户颁发一个token作为其身份标识，其特别之处是使用一个密匙对用户id进行加密，服务端通过同一个密匙对token进行解密，这样通过token的加密解密替代了保存session id。常用的加密算法有SHA-256


## http与https
**参考文章：https://blog.csdn.net/zhttly/article/details/82895713
https://www.jianshu.com/p/8b5350d373fe
https://www.cnblogs.com/jesse131/p/9080925.html
https://blog.csdn.net/qq_38289815/article/details/80969419**  

Http是明文的数据传输协议，协议数据未经过加密，会存在安全问题  
https中的数据会经过加密，可以认为是Http+ssl/tls的组合，https提供数据加密，双向身份校验，防篡改服务  
- http的默认端口是80，https的默认端口是443
- 在OSI网络模型中，https的加密是在传输层完成的

#### https连接建立过程
- 首先client向服务端发送建立https连接请求
- 服务端向客户端传输证书，其中包含公匙和一些其他信息(证书颁发机构，过期时间)
- 客服端进行证书验证(机构是否可信，是否过期),验证通过后，生成对话密匙，将对话密匙用公匙加密，发送到服务端
- 服务端用私匙解密数据，得到对话密匙，然后服务端和客户端就可以通过这个密匙通信

在这个连接建立的过程中，使用非对称密匙进行对话密匙的加密，而对话密匙是对称的  
**非对称密匙**是发布一个公匙，用户用公匙加密信息，而解密使用另一个私匙，相比于使用同一个密匙的**对称密匙**，其解密速度更慢  
所以SSL中，使用非对称密匙加密对话密匙，这样数据量很小，而对话密匙是对称的，用它来加密传输的文件，其精髓就是两套密匙  

#### https防篡改原理
首先，https加密数据，通过非对称密匙和对称密匙，可以实现客户端和服务端省份的双向校验。  
对于防篡改，在传输数据前，会对原文进行hash，生成一个**摘要**，通过概要不能复原数据，并且相同原文对应一个摘要，在数据传输时，将该摘要也加密传输，在另一端解密原文后，对应生成hash，与解密后的摘要对比，若不同说明数据被篡改。

#### https的缺点
- https的握手过程降低了响应速度
- https复杂的通信过程和加密解密会给服务端和客户端带来负担
- https的缓存更加难以实现
- 免费证书少，一般SSL需要钱

## http/1.0和http/1.1
http1.0是短连接的，每一次请求都对应握手和挥手的过程，传输效率低  
http1.1是长连接，在一次握手之后可以进行多次请求，直到挥手断开连接  
http1.1中加入管道，在一次请求发送后不同等待响应，可立即发送第二个请求，但服务端的响应苏姚按照顺序返回，如果没有收到第一个请求，不会响应后面的请求  
这会造成请求的队首阻塞，在http/2.0中，响应不需要按照顺序。


## 从输入url到显示页面都发生了什么
- DNS解析
根据域名获得IP地址
- 创建TCP连接
TCP三次握手
- 提交http请求
- 服务端处理请求并返回响应
- 浏览器收到响应报文
- 浏览器渲染展示页面