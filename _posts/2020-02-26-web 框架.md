---
title: web 框架
auther: ahou
layout: post
---

## Spring

Spring默认使用JDK动态代理，在类没有实现接口时使用CGLib  

#### AOP介绍
**参考文章：https://blog.csdn.net/u013789656/article/details/80938217?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task
https://www.cnblogs.com/Fantastic-Code/p/11593544.html**
AOP即面向切面编程，通常用于将频繁使用的功能代码封装起来，作为切面插入到需要的业务流程中，避免对业务流程的侵入。比如事务管理，性能监视，安全检查，实现日志。  
底层的实现是动态代理，有JDK动态代理和CGLib动态代理两种代理方式  

**AOP实现方式：**  
**参考文章：https://www.jianshu.com/p/f6ce9de9d2e6**
- XML配置中通过代理实现
- XML配置中通过<aop:config>实现，这种方法也有两种形式：使用<aop:aspect>标签定义切面将通知与切点对应；使用<aop:adviser>定义通知者（相当于切面）将通知与切点对应 
- 使用AspectJ注解方式

**相关术语：**    
- Aspect，切面，一般是一些通用的功能模块
- Advice，通知，是切面的具体实现方法，分为前置通知（Before），后置通知(AfterReturing)，异常通知AfterThrowing，最终通知（After），环绕通知(Around)，实现方法属于哪类，有具体的配置或注解指定
- Pointcut，切入点，实际的业务流程中需要插入切面的位置
- JoinPoint，连接点，程序运行时目标方法的信息都会封装到这个对象中，包含目标方法所在类，参数，执行返回值等。
- Target，目标对象，表示被切面通知的对象
- Proxy，代理对象，目标对象的代理，动态创建的，在目标对象的方法中加入切面实现的功能
- Weaving，切入，将切面切入到目标对象创建动态代理的过程，这个过程可以发生在编译期，类装载期和运行期

**几种通知的执行顺序：** 
Around --》Before --》目标方法 --》Around --》After --》AfterReturning --(如果抛出异常)》AfterThrowing  
After是无论方法是否抛出异常都要进行的处理  
AfterReturning在方法正常return才会进行的处理  

**Spring AOP与AspectJ的区别：**
- Spring是动态代理，AspectJ是静态代理，需要自己通过编译期编译

#### Spring声明式事务配置有几种
- 注解配置
配置事务管理器，开启注解事务，在对应的类或类的方法上加注解@Transactional
- 配置文件方式
传播特性配置，配置事务管理器，声明式事务AOP配置(表明哪些切点遵循传播特性的配置)

#### Spring中事务传播特性
**参考文章：https://blog.csdn.net/soonfly/article/details/70305683?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task**
Spring中共有七种事务传播特性，事务传播特性是指在有多个事务方法时，一个事务方法被另一个事务方法调用，它的事务如何进行
假设有事务方法A和B，其中A中调用了B，B不调用其他事务方法  

``` java
void A(){
    statement
    B();
}
void B(){
    statement
}
```

- PROPAGATION_REQUIRED，没有事务则开启事务，有事务则支持  
当调用B时，没有事务就开启事务，当先调用A开启了事务，A中调用B时，AB共用一个事务
- PROPAGATION_SUPPORTS，有事务则支持，没有事务就非事务执行  
当调用B时，没有事务就不再事务中执行，当先调用A开启了事务，A中调用B时，AB共用一个事务
- PROPAGATION_MANDATORY，没有事务抛出异常，有事务则支持事务  
当调用B时，没有事务就抛出异常，当先调用A开启了事务，A中调用B时，AB共用一个事务
- PROPAGATION_REQUIRES_NEW，方法单独执行时开启事务，如果有存在的事务，会将那个事务挂起，需要使用**JtaTransactionManager**作为事务管理器  
当调用B时，没有事务就开启事务，当先调用A开启了事务，A中调用B时，A的事务会被挂起，那么两个事务的回滚是独立的
- PROPAGATION_NOT_SUPPORTED，总是非事务执行，如果已经有事务，会挂起事务  
当调用B时，不开启事务，当先调用A开启了事务，A中调用B时，A的事务会被挂起
- PROPAGATION_NEVER， 不开启事务，有事务存在就抛出异常
当调用B时，不开启事务，当先调用A开启了事务，A中调用B时，会抛出异常
- PROPAGATION_NESTED，没有事务时按照REQUIRED执行，有事务时开启事务，与外层事务嵌套，内层事务失败只回滚内层事务，外层事务失败会将内外层都回滚，外层事务提交时，内层事务才完成提交
当调用B时，不开启事务，当先调用A开启了事务，A中调用B时，B也开启一个事务，B失败只回滚B的操作，A失败时回滚包括B中的操作

**PROPAGATION_REQUIRED_NEW和PROPAGATION_NESTED的区别：**  
两种传播特性下，在存在事务时都会再开启一个事务，但NESTED下，外层事务回滚会包括内层事务操作，REQUIRED_NEW下，内外层分离，外层事务回滚不影响内层事务已经进行的操作  


## Nginx
**参考文章：https://www.php.cn/nginx/423510.html
https://developer.51cto.com/art/201910/605110.htm**  

**Nginx的反向代理：** 客户端把请求发给Nginx，Nginx再将请求交给服务器处理，然后再把请求的响应转交给客户端。  
反向代理可以保证内网安全和实现负载均衡  
反向代理跟正向代理的区别是，正向代理的代理是介于客户和服务器之间的第三方，而Nginx的反向代理是属于服务端的设备，有服务端维护和设置。

#### Nginx负载均衡
- 根据权重确定随机选中概率
- 轮训，权重轮训
- 最小链接数，哪个服务器的链接数少，就分配给哪个服务器。
- IP hash，根据IP的Hash值对应到服务器，保证同一个IP总能由同一个服务器提供服务，可以解决session共享问题
- url hash，根据url的Hash值对应到服务器，同一个地址访问总由同一个服务器响应，缓存效率更高

#### 四层负载均衡与七层负载均衡区别
四层负载均衡基于TCP和UDP协议，通过IP+端口号接受请求并转发到服务器。  
七层负载均衡基于HTTP协议，通过url或主机名接收请求并转发到服务器。  

## Dubbo Dubbox
**参考文章：[dubbo负载均衡与容错](https://www.cnblogs.com/xhj123/p/9087532.html)**  

#### Dubbo 容错
- Failover，失败重试，设定最大重试次数
- Failfast，快速失败，失败了之后，立即报错
- Failsafe，调用出现异常时，直接忽略，这种模式可以用于写入日志
- Forking 有请求是同时向多个提供者发出请求，只要有一个成功返回就算是成功调用。浪费资源，用于实时性要求比较高的场合
Dubbo的容错机制还可以定制，根据提供的接口Cluster进行自定义策略

#### Dubbo负载均衡
**参考文章：[dubbo四种负载均衡策略](https://blog.csdn.net/qq_23864915/article/details/90524467?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task)
**
- Random，权重随机，根据权重确定随机选中概率
- RoundRobin，轮询，基于加权的轮训算法，在轮询时，它们收到的请求数接近或等于它们的权重比。
- LeastActive，最少活跃调用，请求优先分配给活跃数小的服务提供者。刚开始每台提供者的活跃数都为0，每收到一个请求，活跃数加1。最小的活跃数有多个提供者时，根据权重确定选择谁。
- ConsistentHash，一致性hash，根据参数hash确定分配，相同参数的请求总是发到同一个提供者，缺省只对第一个参数hash，当某一台机器挂了，根据虚拟节点把请求平摊给其他提供者，不会给系统带来很大的震荡。

#### Dubbo与Spring Cloud 比较
- dubbo 传输远快于springcloud  
- dubbo服务提供方与调用方接口依赖方式太强：我们为每个微服务定义了各自的service抽象接口，并通过持续集成发布到私有仓库中，调用方应用对微服务提供的抽象接口存在强依赖关系
springcloud REST调用方式相比RPC更为轻量化，服务提供方和调用方的依赖只是依靠一纸契约，不存在代码级别的强依赖。

## RPC
**参考文章：https://blog.csdn.net/weixin_45191798/article/details/97620171**
RPC （远程过程调用）
本地调用方式时，先将相关参数(代表函数的call ID和函数参数)序列化，然后通过网络传输到服务端，在服务端反序列化后，调用目标方法进行处理，处理的结果再序列化后返回到调用端。

#### RPC的几个关键点
- 代理，由于调用的过程在远端，不能直接使用目标主机的对象，本地需要实现代理，隐藏与远程主机的通信，反序列化等细节。可以使用JDK的动态代理，或者第三方CGLib动态代理。
- 序列化，传输需要字节流的数据，所以本地的参数需要经过序列化，可以使用jdk的序列化方法，或者使用第三方序列化方法，比如hession
- 传输，数据需要通过通信在调用端和服务的提供端传输，需要选择合适的传输方式，有无阻塞，能否复用等。
- 实例化，传输的数据在接收端需要反序列化为相应的对象

**需要注意的点：**
- 序列化速度，Dubbo默认使用的是速度较快的Hession
- 序列化后数据大小，可以通过哈夫曼编码减小数据的大小，保证更快地传输
- 网络传输速度，它直接决定了服务响应的速度，使用网络传输速率更高方式，尽量支持多线程，高并发。Dubbo使用Netty（非阻塞，多路复用IO）



## MyBatis

#### Mybatis中的mapper接口为什么不需要实现类
在Mybatis中，我们操作数据库时，一般针对一个表会建立一个xxxMapper.xml文件,然后定义一个xxxMapper接口，在使用时便可直接新建接口对象进行相应的数据库操作，并没有定义接口的实现类。  
该现象背后的原理是动态代理，在使用动态代理时，并不一定要接口实现类作为被代理类  
通过Proxy获得代理对象后，重写InvocationHandler的实现类的invoke方法，根据不同的method的名字可以对应的调用xxxMapper.xml中定义的数据库操作。相当于在invoke中实现方法，不需要调用接口实现类的方法

#### 动态SQL
通过一些条件语句等动态的调整SQL语句的内容  
通常使用的标签有if where （choose when otherwise） set trim


## SpringMVC
**参考文章：https://blog.csdn.net/a745233700/article/details/80963758?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task**  

SpringMVC是MVC设计模式的一个轻量级实现框架，基于Java编写。实现了web应用模块的清晰解耦

#### SpringMVC处理流程
1. DispitcherServlet前端控制器接受请求
2. 由处理映射器HandlerMapper映射请求，得到处理器及处理器拦截器一并返回给DispatcherServlet
3. DispatcherServlet调用HandlerAdapter处理器适配器
4. 处理器适配器HandlerAdapter调用具体处理器Handler
5. Handler返回ModelAndView，最终返回给DispatcherServlet
6. DispatcherServlet对调用视图解析器ViewResolver对ModelAndView进行解析
7. ViewResolver返回具体的view
8. DispatcherServlet对view进行渲染，填充model到view中
9. DispatcherServlet响应用户

#### SpringMVC拦截器
拦截器有两种实现方式：
- 实现HandlerIntercepter接口
- 继承HandlerInterceptor接口的实现类，比如Spring中提供的HandlerInterceptorAdapter抽象类
编写HandlerIntercepter接口，实现其中的preHandle，postHandle和afterCompletion方法，实现需要的业务逻辑，比如登录验证等
在XML配置文件中配置拦截的请求
- preHandle，在Controller执行前，返回boolean类型，如果返回false，请求结束，返回true才会调用接下来的Interceptor和Controller。其执行顺序为声明顺序
- postHandler，在Controller执行后调用，在ModelAndView渲染之前执行，其执行顺序与preHandler相反，相当于"((Controller))"这种括号匹配
- afterCompletion,在请求结束后执行
拦截器可以有多个，根据声明顺序链式调用