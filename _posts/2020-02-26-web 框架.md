---
title: web 框架
auther: ahou
layout: post
---

## Spring
#### AOP介绍
AOP即面向切面编程，通常用于将频繁使用的功能代码封装起来，比如事务的开启和提交操作，实现日志。  
其底层的实现是动态代理，有JDK动态代理和CGLib动态代理两种代理方式
AOP实现方式：  
- XML配置文件
- @AspectJ注解方式

相关术语：  
- Aspect，切面，一般是一些通用的功能模块
- join point，连接点，实际的业务流程中需要插入切面的位置
- Advice，通知，是切面的具体实现方法，分为前置通知（Before），后置通知(AfterReturing)，异常通知AfterThrowing，最终通知（After），环绕通知(Around)，实现方法属于哪类，有具体的配置或注解指定



## Nginx
**参考文章：https://www.php.cn/nginx/423510.html
https://developer.51cto.com/art/201910/605110.htm**  

**Nginx的反向代理：** 客户端把请求发给Nginx，Nginx再将请求交给服务器处理，然后再把请求的响应转交给客户端。  
反向代理可以保证内网安全和实现负载均衡  
反向代理跟正向代理的区别是，正向代理的代理是介于客户和服务器之间的第三方，而Nginx的反向代理是属于服务端的设备，有服务端维护和设置。

#### Nginx负载均衡
- 根据权重确定随机选中概率
- 轮训，权重轮训
- 最小链接数，哪个服务器的链接数少，就分配给哪个服务器。
- IP hash，根据IP的Hash值对应到服务器，保证同一个IP总能由同一个服务器提供服务，可以解决session共享问题
- url hash，根据url的Hash值对应到服务器，同一个地址访问总由同一个服务器响应，缓存效率更高

## Dubbo Dubbox
**参考文章：[dubbo负载均衡与容错](https://www.cnblogs.com/xhj123/p/9087532.html)**  

#### Dubbo 容错
- Failover，失败重试，设定最大重试次数
- Failfast，快速失败，失败了之后，立即报错
- Failsafe，调用出现异常时，直接忽略，这种模式可以用于写入日志
- Forking 有请求是同时向多个提供者发出请求，只要有一个成功返回就算是成功调用。浪费资源，用于实时性要求比较高的场合
Dubbo的容错机制还可以定制，根据提供的接口Cluster进行自定义策略

#### Dubbo负载均衡
**参考文章：[dubbo四种负载均衡策略](https://blog.csdn.net/qq_23864915/article/details/90524467?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task)
**
- Random，权重随机，根据权重确定随机选中概率
- RoundRobin，轮询，基于加权的轮训算法，在轮询时，它们收到的请求数接近或等于它们的权重比。
- LeastActive，最少活跃调用，请求优先分配给活跃数小的服务提供者。刚开始每台提供者的活跃数都为0，每收到一个请求，活跃数加1。最小的活跃数有多个提供者时，根据权重确定选择谁。
- ConsistentHash，一致性hash，根据参数hash确定分配，相同参数的请求总是发到同一个提供者，缺省只对第一个参数hash，当某一台机器挂了，根据虚拟节点把请求平摊给其他提供者，不会给系统带来很大的震荡。

#### Dubbo与Spring Cloud 比较
- dubbo 传输远快于springcloud  
- dubbo服务提供方与调用方接口依赖方式太强：我们为每个微服务定义了各自的service抽象接口，并通过持续集成发布到私有仓库中，调用方应用对微服务提供的抽象接口存在强依赖关系
springcloud REST调用方式相比RPC更为轻量化，服务提供方和调用方的依赖只是依靠一纸契约，不存在代码级别的强依赖。

## RPC
**参考文章：https://blog.csdn.net/weixin_45191798/article/details/97620171**
RPC （远程过程调用）
本地调用方式时，先将相关参数(代表函数的call ID和函数参数)序列化，然后通过网络传输到服务端，在服务端反序列化后，调用目标方法进行处理，处理的结果再序列化后返回到调用端。

#### RPC的几个关键点
- 代理，由于调用的过程在远端，不能直接使用目标主机的对象，本地需要实现代理，隐藏与远程主机的通信，反序列化等细节。可以使用JDK的动态代理，或者第三方CGLib动态代理。
- 序列化，传输需要字节流的数据，所以本地的参数需要经过序列化，可以使用jdk的序列化方法，或者使用第三方序列化方法，比如hession
- 传输，数据需要通过通信在调用端和服务的提供端传输，需要选择合适的传输方式，有无阻塞，能否复用等。
- 实例化，传输的数据在接收端需要反序列化为相应的对象

**需要注意的点：**
- 序列化速度，Dubbo默认使用的是速度较快的Hession
- 序列化后数据大小，可以通过哈夫曼编码减小数据的大小，保证更快地传输
- 网络传输速度，它直接决定了服务响应的速度，使用网络传输速率更高方式，尽量支持多线程，高并发。Dubbo使用Netty（非阻塞，多路复用IO）



## MyBatis

#### 动态SQL
通过一些条件语句等动态的调整SQL语句的内容  
通常使用的标签有if where （choose when otherwise） set trim
