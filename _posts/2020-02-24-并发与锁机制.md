---
title: Java 并发与锁机制
auther: ahou
layout: post
---

**参考文章：https://blog.csdn.net/weixin_41950473/article/details/92080488**

## Java 锁分类
![enter description here](./images/1582510225239.png)

**轻量锁：** 多个线程竞争资源时，未获取到资源的线程自旋等待锁释放    
**重量锁：** 多个线程竞争资源时，未获取到资源的线程阻塞等待被唤醒  

**悲观锁：** 操作前加锁，synchronized和Lock接口实现类都是悲观锁  
**乐观锁：** 访问不加锁，一般通过CAS来实现。在更新值前检查是否被修改，没有被修改则直接更新，如果被修改则重新计算并重试，java.util.concurrent.atomic中的原子类是通过CAS来实现的。
**优缺点：**
悲观锁有锁开销，乐观锁自旋操作占用cpu资源，ABA问题(可通过加入版本来解决)

**自旋锁：**  
**非自旋锁：**  
**优缺点：**
**自旋锁避免了cpu进行状态切换，但占用了cpu的处理时间**，阻塞或唤醒一个 Java 线程需要操作系统切换 CPU 状态来完成，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长。所以自旋锁就可以避免 CPU 切换带来的性能、时间等影响。  
**适应性自旋锁：**自旋的时间不再固定，而是由前一次在一个同一个锁上的自旋时间和锁对象来决定。

**偏向锁：** 偏向锁是指一个资源一直被一个线程访问，那么该线程会自动获取锁，减少获取锁的开销  
一些情况下，锁总是被一个线程获得，为了减少多次获取锁的开销，设计了偏向锁  
偏向锁的获取过程：
当一个线程访问同步块时，如果其对象允许偏向锁  
检查对象MarkWord中的线程ID是否是当前线程，如果是则直接访问代码块
如果不是，那么当前线程需要通过CAS来获取锁，获取成功后，MarkWord中的线程ID修改为当前线程
如果获取失败，那么说明当前锁存在竞争，那么将在到达全局安全点时升级为轻量锁。

**公平锁：** 在拥有锁的线程释放锁时，优先让等待时间长的线程获取锁，也就是有排队先到先得
**不公平锁：** 加锁时先直接竞争锁，竞争不到再进行排队
**优缺点：** 
公平锁的吞吐量相对非公平锁较低，因为它在分配锁时要唤醒等待的线程，在不公平锁中，如果刚好有线程请求锁，可以直接获取，减少了唤醒等待线程的时间。
线程持有锁的时间比较长时可以使用公平锁，这样对吞吐凉的影响并不大  
synchronized是不公平锁，Lock可以选择是公平锁或者不公平锁

**可重入锁：** 可重入锁又称递归锁，是指一个线程在访问一个方法获得锁后，在访问其他的方法可以不用重新获得锁，前提是它们是同一个对象或类的锁。  
**不可重入锁：** 线程获得一个同步方法的锁之后，在访问锁对象下的方法，仍然需要获取锁  
不可重入锁容易发生阻塞

**排他锁：** 锁一次只能被一个线程持有。典型的是写操作的锁，在进行写操作时，其他线程不同同时对资源进行读或写。  
**共享锁：** 锁可以同时被多个线程持有。典型的是读操作的锁，对资源的读操作可以多个线程同时进行，但不允许同时有写操作。  


