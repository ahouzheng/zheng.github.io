---
title: Java 并发与锁机制
auther: ahou
layout: post
---

**参考文章：https://blog.csdn.net/weixin_41950473/article/details/92080488**

## Java 锁分类
![enter description here](./images/1582510225239.png)

**轻量锁：** 多个线程竞争资源时，未获取到资源的线程自旋等待锁释放    
**重量锁：** 多个线程竞争资源时，未获取到资源的线程阻塞等待被唤醒  

**悲观锁：** 操作前加锁，synchronized和Lock接口实现类都是悲观锁  
**乐观锁：** 访问不加锁，一般通过CAS来实现。在更新值前检查是否被修改，没有被修改则直接更新，如果被修改则重新计算并重试，java.util.concurrent.atomic中的原子类是通过CAS来实现的。
**优缺点：**
悲观锁有锁开销，乐观锁自旋操作占用cpu资源，ABA问题(可通过加入版本来解决)

**自旋锁：**  
**非自旋锁：**  
**优缺点：**
**自旋锁避免了cpu进行状态切换，但占用了cpu的处理时间**，阻塞或唤醒一个 Java 线程需要操作系统切换 CPU 状态来完成，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长。所以自旋锁就可以避免 CPU 切换带来的性能、时间等影响。  
**适应性自旋锁：**自旋的时间不再固定，而是由前一次在一个同一个锁上的自旋时间和锁对象来决定。

**偏向锁：** 偏向锁是指一个资源一直被一个线程访问，那么该线程会自动获取锁，减少获取锁的开销  
一些情况下，锁总是被一个线程获得，为了减少多次获取锁的开销，设计了偏向锁  
偏向锁的获取过程：
当一个线程访问同步块时，如果其对象允许偏向锁  
检查对象MarkWord中的线程ID是否是当前线程，如果是则直接访问代码块
如果不是，那么当前线程需要通过CAS来获取锁，获取成功后，MarkWord中的线程ID修改为当前线程
如果获取失败，那么说明当前锁存在竞争，那么将在到达全局安全点时升级为轻量锁。

**公平锁：** 在拥有锁的线程释放锁时，优先让等待时间长的线程获取锁，也就是有排队先到先得
**不公平锁：** 加锁时先直接竞争锁，竞争不到再进行排队  
**优缺点：** 
公平锁的吞吐量相对非公平锁较低，因为它在分配锁时要唤醒等待的线程，在不公平锁中，如果刚好有线程请求锁，可以直接获取，减少了唤醒等待线程的时间。
线程持有锁的时间比较长时可以使用公平锁，这样对吞吐凉的影响并不大  
synchronized是不公平锁，Lock可以选择是公平锁或者不公平锁

**可重入锁：** 可重入锁又称递归锁，是指一个线程在外层获得锁后，在内层依然可以重复使用锁，前提是它们是同一个对象或类的锁。  
**不可重入锁：** 线程获得一个同步方法的锁之后，在访问锁对象下的方法，仍然需要获取锁  
不可重入锁容易发生阻塞  
可重入锁内部有一个加锁计数器，每进入锁Lock一次，计数器加1，unlock一次，计数器减1，当计数器归零时，锁被释放

**排他锁：** 锁一次只能被一个线程持有。典型的是写操作的锁，在进行写操作时，其他线程不同同时对资源进行读或写。  
**共享锁：** 锁可以同时被多个线程持有。典型的是读操作的锁，对资源的读操作可以多个线程同时进行，但不允许同时有写操作。 

**可中断锁：** 线程在获取锁的过程中可以中断，Lock接口下的锁是可以中断的，synchronized是不可中断锁

**CAS缺点：** ABA 循环重试浪费cpu资源 一次只能对一个共享变量进行操作

## synchronized
**加锁方式：**如果是对非静态方法同步，作用对象为方法所在对象  
如果是对静态方法同步，作用对象是类的Class对象  
如果是对语句块同步，需要指定作用对象  

## volatile
synchronized可以在多线程环境下保证可见性，有序性和原子性，但synchronized是一个相对重量型的操作，对系统性能影响较大，在Java中提供了volatile关键字来提供可见性和有序性的保证，但只能保证变量单独的读或写操作是原子的。  
**可见性：** volatile修饰的变量，在写操作后强制刷新到主内存  
在变量进行修改后，其他线程工作内存中的值将会失效，它们在访问时需要到主内存中进行读取  
以此来保证变量在多线程中的可见性。  
**有序性：** 被volatile修饰的变量，虚拟机会在其读写命令前后加上内存屏障，避免指令间的重排序，保证其有序性。
在变量写操作前加入StoreStore，写操作后加入StoreLoad  
在变量读操作前加入LoadLoad，读操作后加入LoadStore  
Java程序中会存在三种重排序：编译器重排序，系统重排序和内存访问重排序 

**volatile和synchronized：**  
volatile不提供加锁操作，不会造成线程的阻塞，是轻量级的实现多线程共享变量可见性的方式  
从可见性角度看，volatile变量写操作相当于对出同步代码块，读操作相当于进入同步代码块  
volatile并不能像synchronized一样绝对的保证线程安全  
当变量的当前值依赖以前的值的时候，volatile是不安全的，比如 var++ 操作，可能多个线程，读取到当前值a后同时进行操作，写入之后var等于a+1，所有线程只使结果增加了1
或者确保只有一个线程对变量进行写入

